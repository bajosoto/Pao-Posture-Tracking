//
//  PaoDrawings.swift
//  Pao
//
//  Created by Sergio Soto on 10/4/17.
//  Copyright Â© 2017 Pao. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class PaoDrawings : NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawPaoEggCanvas(frame: CGRect = CGRect(x: 0, y: 0, width: 250, height: 250), time: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let paoDrop = UIColor(red: 0.475, green: 0.749, blue: 0.906, alpha: 1.000)
        let paoButtonCenter = UIColor(red: 0.818, green: 0.934, blue: 1.000, alpha: 1.000)
        let paoButtonContour = UIColor(red: 0.282, green: 0.686, blue: 0.918, alpha: 1.000)
        let highlight = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [paoDrop.cgColor, paoButtonCenter.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black.withAlphaComponent(0.33)
        shadow.shadowOffset = CGSize(width: 1, height: 1)
        shadow.shadowBlurRadius = 2
        let watershadow = NSShadow()
        watershadow.shadowColor = paoDrop.withAlphaComponent(0.33 * paoDrop.cgColor.alpha)
        watershadow.shadowOffset = CGSize(width: 0, height: 1)
        watershadow.shadowBlurRadius = 3

        //// Variable Declarations
        let timeinverse: CGFloat = 1 - time
        let sinoftime: CGFloat = sin(360 * time * CGFloat.pi/180) * 8

        //// Water Drawing
        context.saveGState()
        context.translateBy(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.77992 * frame.height)
        context.scaleBy(x: time, y: time)

        context.saveGState()
        context.setAlpha(timeinverse)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let waterPath = UIBezierPath()
        waterPath.move(to: CGPoint(x: -0, y: -34.86))
        waterPath.addCurve(to: CGPoint(x: -77.55, y: -0), controlPoint1: CGPoint(x: -42.83, y: -34.86), controlPoint2: CGPoint(x: -77.55, y: -19.25))
        waterPath.addCurve(to: CGPoint(x: -0, y: 34.86), controlPoint1: CGPoint(x: -77.55, y: 19.25), controlPoint2: CGPoint(x: -42.83, y: 34.86))
        waterPath.addCurve(to: CGPoint(x: 77.55, y: -0), controlPoint1: CGPoint(x: 42.83, y: 34.86), controlPoint2: CGPoint(x: 77.55, y: 19.25))
        waterPath.addCurve(to: CGPoint(x: 65.62, y: -18.59), controlPoint1: CGPoint(x: 77.55, y: -6.83), controlPoint2: CGPoint(x: 73.18, y: -13.21))
        waterPath.addCurve(to: CGPoint(x: -0, y: -34.86), controlPoint1: CGPoint(x: 51.88, y: -28.36), controlPoint2: CGPoint(x: 27.63, y: -34.86))
        waterPath.close()
        waterPath.move(to: CGPoint(x: 65.85, y: -23.31))
        waterPath.addCurve(to: CGPoint(x: 81, y: -0), controlPoint1: CGPoint(x: 75.39, y: -16.75), controlPoint2: CGPoint(x: 81, y: -8.7))
        waterPath.addCurve(to: CGPoint(x: -0, y: 40.02), controlPoint1: CGPoint(x: 81, y: 22.1), controlPoint2: CGPoint(x: 44.74, y: 40.02))
        waterPath.addCurve(to: CGPoint(x: -81, y: -0), controlPoint1: CGPoint(x: -44.74, y: 40.02), controlPoint2: CGPoint(x: -81, y: 22.1))
        waterPath.addCurve(to: CGPoint(x: 0, y: -40.02), controlPoint1: CGPoint(x: -81, y: -22.1), controlPoint2: CGPoint(x: -44.74, y: -40.02))
        waterPath.addCurve(to: CGPoint(x: 65.85, y: -23.31), controlPoint1: CGPoint(x: 27.13, y: -40.02), controlPoint2: CGPoint(x: 51.15, y: -33.43))
        waterPath.close()
        context.saveGState()
        context.setShadow(offset: watershadow.shadowOffset, blur: watershadow.shadowBlurRadius, color: (watershadow.shadowColor as! UIColor).cgColor)
        paoDrop.setFill()
        waterPath.fill()
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        //// PaoEgg
        context.saveGState()
        context.translateBy(x: frame.maxX - 125, y: frame.maxY - 55.02)
        context.rotate(by: -sinoftime * CGFloat.pi/180)



        //// Oval Drawing
        let ovalPath = UIBezierPath()
        ovalPath.move(to: CGPoint(x: 71.67, y: -76.63))
        ovalPath.addCurve(to: CGPoint(x: -0, y: 5.02), controlPoint1: CGPoint(x: 71.67, y: -31.53), controlPoint2: CGPoint(x: 39.58, y: 5.02))
        ovalPath.addCurve(to: CGPoint(x: -71.67, y: -76.63), controlPoint1: CGPoint(x: -39.58, y: 5.02), controlPoint2: CGPoint(x: -71.67, y: -31.53))
        ovalPath.addCurve(to: CGPoint(x: 0, y: -173.31), controlPoint1: CGPoint(x: -71.67, y: -121.72), controlPoint2: CGPoint(x: -36.92, y: -173.31))
        ovalPath.addCurve(to: CGPoint(x: 71.67, y: -76.63), controlPoint1: CGPoint(x: 36.92, y: -173.31), controlPoint2: CGPoint(x: 71.67, y: -121.72))
        ovalPath.close()
        context.saveGState()
        ovalPath.addClip()
        context.drawRadialGradient(gradient,
            startCenter: CGPoint(x: 24.31, y: -29.74), startRadius: 51.59,
            endCenter: CGPoint(x: -4.34, y: -73.25), endRadius: 108.21,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        paoButtonContour.setStroke()
        ovalPath.lineWidth = 0.2
        ovalPath.lineCapStyle = .round
        ovalPath.stroke()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: -52, y: -119.98, width: 104, height: 105))
        paoButtonContour.setFill()
        oval2Path.fill()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: -48, y: -116.98, width: 96, height: 99))
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        paoButtonCenter.setFill()
        oval3Path.fill()
        context.restoreGState()



        //// Bezier 2 Drawing
        context.saveGState()
        context.setAlpha(0.4)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 25.13, y: -165.59))
        bezier2Path.addCurve(to: CGPoint(x: 71.67, y: -76.63), controlPoint1: CGPoint(x: 51.27, y: -149.53), controlPoint2: CGPoint(x: 71.67, y: -111.17))
        bezier2Path.addCurve(to: CGPoint(x: 11.86, y: 3.91), controlPoint1: CGPoint(x: 71.67, y: -36.14), controlPoint2: CGPoint(x: 45.8, y: -2.53))
        bezier2Path.addCurve(to: CGPoint(x: 43.43, y: -20.76), controlPoint1: CGPoint(x: 21.72, y: -1.42), controlPoint2: CGPoint(x: 33.75, y: -9.27))
        bezier2Path.addCurve(to: CGPoint(x: 54.29, y: -115.3), controlPoint1: CGPoint(x: 65.15, y: -46.55), controlPoint2: CGPoint(x: 62.98, y: -87.37))
        bezier2Path.addCurve(to: CGPoint(x: 25.13, y: -165.59), controlPoint1: CGPoint(x: 47.46, y: -137.28), controlPoint2: CGPoint(x: 39.09, y: -149.68))
        bezier2Path.close()
        highlight.setFill()
        bezier2Path.fill()

        context.restoreGState()



        context.restoreGState()
    }

    @objc public dynamic class func drawPostureBar(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 300, height: 40), resizing: ResizingBehavior = .aspectFit, currentPosture: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 300, height: 40), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 300, y: resizedFrame.height / 40)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 300, resizedFrame.height / 40)


        //// Color Declarations
        let paoDrop = UIColor(red: 0.475, green: 0.749, blue: 0.906, alpha: 1.000)
        let paoButtonCenter = UIColor(red: 0.818, green: 0.934, blue: 1.000, alpha: 1.000)
        let paoButtonContour = UIColor(red: 0.282, green: 0.686, blue: 0.918, alpha: 1.000)
        let gradient2Color = UIColor(red: 0.906, green: 0.475, blue: 0.475, alpha: 1.000)

        //// Gradient Declarations
        let gradient2 = CGGradient(colorsSpace: nil, colors: [gradient2Color.cgColor, paoDrop.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let shadow2 = NSShadow()
        shadow2.shadowColor = UIColor.black.withAlphaComponent(0.18)
        shadow2.shadowOffset = CGSize(width: 0, height: 0)
        shadow2.shadowBlurRadius = 6

        //// Variable Declarations
        let postureInPixels: CGFloat = currentPosture * 294

        //// posture background Drawing
        let postureBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 3, y: 3, width: 294, height: 34), cornerRadius: 17)
        paoButtonCenter.setFill()
        postureBackgroundPath.fill()

        ////// posture background Inner Shadow
        context.saveGState()
        context.clip(to: postureBackgroundPath.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0)
        context.setAlpha((shadow2.shadowColor as! UIColor).cgColor.alpha)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let postureBackgroundOpaqueShadow = (shadow2.shadowColor as! UIColor).withAlphaComponent(1)
        context.setShadow(offset: CGSize(width: shadow2.shadowOffset.width * resizedShadowScale, height: shadow2.shadowOffset.height * resizedShadowScale), blur: shadow2.shadowBlurRadius * resizedShadowScale, color: postureBackgroundOpaqueShadow.cgColor)
        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        postureBackgroundOpaqueShadow.setFill()
        postureBackgroundPath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        context.restoreGState()



        //// border Drawing
        let borderPath = UIBezierPath(roundedRect: CGRect(x: 2, y: 2, width: 296, height: 36), cornerRadius: 18)
        paoButtonContour.setStroke()
        borderPath.lineWidth = 2
        borderPath.lineCapStyle = .round
        borderPath.lineJoinStyle = .round
        borderPath.stroke()


        //// Group
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip clipper
        let clipperPath = UIBezierPath(roundedRect: CGRect(x: 3, y: 3, width: postureInPixels, height: 34), cornerRadius: 17)
        clipperPath.addClip()


        //// posture color Drawing
        let postureColorPath = UIBezierPath(roundedRect: CGRect(x: 3, y: 3, width: 294, height: 34), cornerRadius: 17)
        context.saveGState()
        postureColorPath.addClip()
        context.drawLinearGradient(gradient2,
            start: CGPoint(x: 78.4, y: 22.74),
            end: CGPoint(x: 221.79, y: 22.14),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()

        ////// posture color Inner Shadow
        context.saveGState()
        context.clip(to: postureColorPath.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0)
        context.setAlpha((shadow2.shadowColor as! UIColor).cgColor.alpha)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let postureColorOpaqueShadow = (shadow2.shadowColor as! UIColor).withAlphaComponent(1)
        context.setShadow(offset: CGSize(width: shadow2.shadowOffset.width * resizedShadowScale, height: shadow2.shadowOffset.height * resizedShadowScale), blur: shadow2.shadowBlurRadius * resizedShadowScale, color: postureColorOpaqueShadow.cgColor)
        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        postureColorOpaqueShadow.setFill()
        postureColorPath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        context.restoreGState()



        context.endTransparencyLayer()
        context.restoreGState()
        
        context.restoreGState()

    }




    @objc(PaoDrawingsResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
