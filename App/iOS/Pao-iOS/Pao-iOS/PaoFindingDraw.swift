//
//  PaoFindingDraw.swift
//  PaoFinding
//
//  Created by Sergio Soto on 10/2/17.
//  Copyright Â© 2017 Pao. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class PaoFindingDraw : NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawPaoEggCanvas(frame: CGRect = CGRect(x: 0, y: 0, width: 250, height: 250), time: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let paoBlue = UIColor(red: 0.475, green: 0.749, blue: 0.906, alpha: 1.000)
        let paoButtonCenter = UIColor(red: 0.818, green: 0.934, blue: 1.000, alpha: 1.000)
        let paoButtonCenter2 = UIColor(red: 0.283, green: 0.686, blue: 0.917, alpha: 1.000)
        let highlight = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [paoBlue.cgColor, paoButtonCenter.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black.withAlphaComponent(0.33)
        shadow.shadowOffset = CGSize(width: 1, height: 1)
        shadow.shadowBlurRadius = 2
        let watershadow = NSShadow()
        watershadow.shadowColor = paoBlue.withAlphaComponent(0.33 * paoBlue.cgColor.alpha)
        watershadow.shadowOffset = CGSize(width: 0, height: 1)
        watershadow.shadowBlurRadius = 3

        //// Variable Declarations
        let timeinverse: CGFloat = 1 - time

        //// Water Drawing
        context.saveGState()
        context.translateBy(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.77992 * frame.height)
        context.scaleBy(x: time, y: time)

        context.saveGState()
        context.setAlpha(timeinverse)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let waterPath = UIBezierPath()
        waterPath.move(to: CGPoint(x: -0, y: -34.86))
        waterPath.addCurve(to: CGPoint(x: -77.55, y: -0), controlPoint1: CGPoint(x: -42.83, y: -34.86), controlPoint2: CGPoint(x: -77.55, y: -19.25))
        waterPath.addCurve(to: CGPoint(x: -0, y: 34.86), controlPoint1: CGPoint(x: -77.55, y: 19.25), controlPoint2: CGPoint(x: -42.83, y: 34.86))
        waterPath.addCurve(to: CGPoint(x: 77.55, y: -0), controlPoint1: CGPoint(x: 42.83, y: 34.86), controlPoint2: CGPoint(x: 77.55, y: 19.25))
        waterPath.addCurve(to: CGPoint(x: 65.62, y: -18.59), controlPoint1: CGPoint(x: 77.55, y: -6.83), controlPoint2: CGPoint(x: 73.18, y: -13.21))
        waterPath.addCurve(to: CGPoint(x: -0, y: -34.86), controlPoint1: CGPoint(x: 51.88, y: -28.36), controlPoint2: CGPoint(x: 27.63, y: -34.86))
        waterPath.close()
        waterPath.move(to: CGPoint(x: 65.85, y: -23.31))
        waterPath.addCurve(to: CGPoint(x: 81, y: -0), controlPoint1: CGPoint(x: 75.39, y: -16.75), controlPoint2: CGPoint(x: 81, y: -8.7))
        waterPath.addCurve(to: CGPoint(x: -0, y: 40.02), controlPoint1: CGPoint(x: 81, y: 22.1), controlPoint2: CGPoint(x: 44.74, y: 40.02))
        waterPath.addCurve(to: CGPoint(x: -81, y: -0), controlPoint1: CGPoint(x: -44.74, y: 40.02), controlPoint2: CGPoint(x: -81, y: 22.1))
        waterPath.addCurve(to: CGPoint(x: 0, y: -40.02), controlPoint1: CGPoint(x: -81, y: -22.1), controlPoint2: CGPoint(x: -44.74, y: -40.02))
        waterPath.addCurve(to: CGPoint(x: 65.85, y: -23.31), controlPoint1: CGPoint(x: 27.13, y: -40.02), controlPoint2: CGPoint(x: 51.15, y: -33.43))
        waterPath.close()
        context.saveGState()
        context.setShadow(offset: watershadow.shadowOffset, blur: watershadow.shadowBlurRadius, color: (watershadow.shadowColor as! UIColor).cgColor)
        paoBlue.setFill()
        waterPath.fill()
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath()
        ovalPath.move(to: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.47341 * frame.height))
        ovalPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.80000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.65378 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.65832 * frame.width, y: frame.minY + 0.80000 * frame.height))
        ovalPath.addCurve(to: CGPoint(x: frame.minX + 0.21333 * frame.width, y: frame.minY + 0.47341 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.34168 * frame.width, y: frame.minY + 0.80000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.21333 * frame.width, y: frame.minY + 0.65378 * frame.height))
        ovalPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.08667 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.21333 * frame.width, y: frame.minY + 0.29304 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.35232 * frame.width, y: frame.minY + 0.08667 * frame.height))
        ovalPath.addCurve(to: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.47341 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.64768 * frame.width, y: frame.minY + 0.08667 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.29304 * frame.height))
        ovalPath.close()
        context.saveGState()
        ovalPath.addClip()
        let ovalBounds: CGRect = ovalPath.cgPath.boundingBoxOfPath
        let ovalResizeRatio: CGFloat = min(ovalBounds.width / 143.33, ovalBounds.height / 178.33)
        context.drawRadialGradient(gradient,
            startCenter: CGPoint(x: ovalBounds.midX + 24.31 * ovalResizeRatio, y: ovalBounds.midY + 54.41 * ovalResizeRatio), startRadius: 51.59 * ovalResizeRatio,
            endCenter: CGPoint(x: ovalBounds.midX + -4.34 * ovalResizeRatio, y: ovalBounds.midY + 10.9 * ovalResizeRatio), endRadius: 108.21 * ovalResizeRatio,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        paoButtonCenter2.setStroke()
        ovalPath.lineWidth = 0.2
        ovalPath.lineCapStyle = .round
        ovalPath.stroke()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: frame.minX + fastFloor(frame.width * 0.29200 + 0.5), y: frame.minY + fastFloor(frame.height * 0.30000 + 0.5), width: fastFloor(frame.width * 0.70800 + 0.5) - fastFloor(frame.width * 0.29200 + 0.5), height: fastFloor(frame.height * 0.72000 + 0.5) - fastFloor(frame.height * 0.30000 + 0.5)))
        paoButtonCenter2.setFill()
        oval2Path.fill()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: frame.minX + fastFloor(frame.width * 0.30800 + 0.5), y: frame.minY + fastFloor(frame.height * 0.31200 + 0.5), width: fastFloor(frame.width * 0.69200 + 0.5) - fastFloor(frame.width * 0.30800 + 0.5), height: fastFloor(frame.height * 0.70800 + 0.5) - fastFloor(frame.height * 0.31200 + 0.5)))
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        paoButtonCenter.setFill()
        oval3Path.fill()
        context.restoreGState()



        //// Bezier 2 Drawing
        context.saveGState()
        context.setAlpha(0.4)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.60053 * frame.width, y: frame.minY + 0.11757 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.47341 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.70509 * frame.width, y: frame.minY + 0.18179 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.33523 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.54744 * frame.width, y: frame.minY + 0.79555 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.78667 * frame.width, y: frame.minY + 0.63537 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.68318 * frame.width, y: frame.minY + 0.76980 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.67374 * frame.width, y: frame.minY + 0.69687 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.58687 * frame.width, y: frame.minY + 0.77422 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.63500 * frame.width, y: frame.minY + 0.74285 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.71717 * frame.width, y: frame.minY + 0.31871 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.76061 * frame.width, y: frame.minY + 0.59373 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.75192 * frame.width, y: frame.minY + 0.43044 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.60053 * frame.width, y: frame.minY + 0.11757 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.68983 * frame.width, y: frame.minY + 0.23082 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.65636 * frame.width, y: frame.minY + 0.18120 * frame.height))
        bezier2Path.close()
        highlight.setFill()
        bezier2Path.fill()

        context.restoreGState()
    }

}
